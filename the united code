<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nose-Scroll: Gesture Controlled Interface</title>
    <!-- MediaPipe CDNs -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs" type="module"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --accent: #38bdf8;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* --- Header & Controls --- */
        header {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 1rem 2rem;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        button {
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        #btn-toggle {
            background-color: var(--accent);
            color: var(--bg-color);
        }

        #btn-toggle.active {
            background-color: #ef4444;
            color: white;
        }

        #btn-calibrate {
            background-color: var(--card-bg);
            color: white;
            border: 1px solid var(--accent);
        }

        /* --- Main Content Area --- */
        main {
            max-width: 800px;
            margin: 100px auto;
            padding: 2rem;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 3rem;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 8px;
            background: #334155;
        }

        /* --- Tracking Overlay --- */
        #tracking-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--accent);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            z-index: 1000;
        }

        video#webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror view */
        }

        canvas#overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }

        /* --- Visual Feedback Cues --- */
        #scroll-indicator {
            position: fixed;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 3rem;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            pointer-events: none;
            z-index: 200;
        }

        #scroll-indicator.active {
            opacity: 0.8;
            transform: translateY(-50%) scale(1.2);
        }

        .status-badge {
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 4px;
            background: #334155;
            margin-left: 10px;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading-overlay">
        <h2>Initializing Computer Vision...</h2>
        <p>Loading MediaPipe Face Landmarker</p>
    </div>

    <header>
        <div>
            <h1 style="margin:0; font-size: 1.2rem;">VisionScroll <span id="status" class="status-badge">Model Ready</span></h1>
        </div>
        <div class="controls">
            <button id="btn-calibrate">Reset Center</button>
            <button id="btn-toggle">Start Camera</button>
        </div>
    </header>

    <div id="tracking-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
    </div>

    <div id="scroll-indicator">⬇️</div>

    <main>
        <article>
            <h1>The Future of Hands-Free Browsing</h1>
            <p style="font-size: 1.2rem; color: var(--text-muted);">Enable your camera and move your head up or down to scroll. Keep your nose in the "dead zone" to read comfortably.</p>
            
            <p>Artificial intelligence and computer vision are redefining how we interact with the digital world. By leveraging MediaPipe's Face Landmarker, we can track facial points in real-time with sub-millisecond latency directly in the browser.</p>
            
            <div class="gallery" id="gallery-container">
                <!-- Dynamically generated items -->
            </div>

            <section style="margin-top: 4rem;">
                <h2>How it Works</h2>
                <p>We track Landmark #4 (the tip of the nose). Upon calibration, we store the Y-coordinate of your nose in the viewport. If you tilt your head up (nose moves down in the camera frame), the page scrolls down. If you tilt your head down (nose moves up), the page scrolls up.</p>
                <p>A "Dead Zone" of 40 pixels prevents the page from jittering while you are naturally moving your head to read text.</p>
            </section>

            <div class="gallery" id="gallery-container-2"></div>
        </article>
    </main>

    <script type="module">
        import {
            FaceLandmarker,
            FilesetResolver
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

        // --- DOM Elements ---
        const video = document.getElementById("webcam");
        const canvas = document.getElementById("overlay");
        const ctx = canvas.getContext("2d");
        const btnToggle = document.getElementById("btn-toggle");
        const btnCalibrate = document.getElementById("btn-calibrate");
        const scrollIndicator = document.getElementById("scroll-indicator");
        const loadingScreen = document.getElementById("loading");

        // --- State Variables ---
        let faceLandmarker;
        let runningMode = "VIDEO";
        let lastVideoTime = -1;
        let isCameraActive = false;
        let calibrationY = 0.5; // Normalized Y (0 to 1)
        
        // --- Hyperparameters ---
        const DEAD_ZONE = 0.05; // 5% of height
        const SCROLL_SPEED = 25; // Pixels per frame
        const NOSE_LANDMARK_INDEX = 4; // Tip of the nose

        // Populate Gallery
        const gallery1 = document.getElementById('gallery-container');
        const gallery2 = document.getElementById('gallery-container-2');
        for(let i=1; i<=12; i++) {
            const card = `<div class="card"><img src="https://picsum.photos/seed/${i+20}/400/300" alt="Sample"><h3>Project Node ${i}</h3><p>Detailed analysis of gesture metrics.</p></div>`;
            if(i <= 6) gallery1.innerHTML += card;
            else gallery2.innerHTML += card;
        }

        // --- Initialize MediaPipe ---
        async function initializeModel() {
            const filesetResolver = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: true,
                runningMode: runningMode,
                numFaces: 1
            });
            loadingScreen.style.opacity = '0';
            setTimeout(() => loadingScreen.remove(), 500);
        }

        // --- Camera Logic ---
        async function toggleCamera() {
            if (isCameraActive) {
                const stream = video.srcObject;
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
                isCameraActive = false;
                btnToggle.textContent = "Start Camera";
                btnToggle.classList.remove('active');
            } else {
                try {
                    const constraints = { video: { width: 640, height: 480 } };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    isCameraActive = true;
                    btnToggle.textContent = "Stop Camera";
                    btnToggle.classList.add('active');
                    
                    // Auto-calibrate after 2 seconds
                    setTimeout(calibrate, 2000);
                } catch (err) {
                    console.error("Camera access denied", err);
                }
            }
        }

        function calibrate() {
            // We'll capture the current nose position in the next frame
            window.isCalibrating = true;
        }

        // --- Prediction & Gesture Engine ---
        async function predictWebcam() {
            if (!isCameraActive) return;

            // Sync canvas size to video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, startTimeMs);

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const nose = results.faceLandmarks[0][NOSE_LANDMARK_INDEX];

                    // Handle Calibration
                    if (window.isCalibrating) {
                        calibrationY = nose.y;
                        window.isCalibrating = false;
                        console.log("Calibrated center at:", calibrationY);
                    }

                    // Draw Nose Dot
                    ctx.fillStyle = "#38bdf8";
                    ctx.beginPath();
                    ctx.arc(nose.x * canvas.width, nose.y * canvas.height, 5, 0, 2 * Math.PI);
                    ctx.fill();

                    // Gesture Math
                    // We compare current nose.y to calibrationY
                    // Remember: in screen coords, Y increases downwards.
                    const deltaY = nose.y - calibrationY;

                    if (Math.abs(deltaY) > DEAD_ZONE) {
                        if (deltaY > 0) {
                            // Nose moved down relative to camera -> head tilted up -> scroll DOWN
                            window.scrollBy({ top: SCROLL_SPEED, behavior: 'auto' });
                            updateIndicator('⬇️', true);
                        } else {
                            // Nose moved up relative to camera -> head tilted down -> scroll UP
                            window.scrollBy({ top: -SCROLL_SPEED, behavior: 'auto' });
                            updateIndicator('⬆️', true);
                        }
                    } else {
                        updateIndicator('', false);
                    }
                }
            }

            if (isCameraActive) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        function updateIndicator(symbol, show) {
            if (show) {
                scrollIndicator.textContent = symbol;
                scrollIndicator.classList.add('active');
            } else {
                scrollIndicator.classList.remove('active');
            }
        }

        // Listeners
        btnToggle.addEventListener("click", toggleCamera);
        btnCalibrate.addEventListener("click", calibrate);

        // Init
        initializeModel();

    </script>
</body>
</html>
